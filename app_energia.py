# -*- coding: utf-8 -*-
"""Aplicaci√≥n de Consultor√≠a Energ√©tica Avanzada

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FQ6GLUxBZShMAH5Urnqu8jlDGvYxxs8z
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np
from datetime import datetime

# --- CONFIGURACI√ìN DE P√ÅGINA ---
st.set_page_config(
    page_title="Consultor√≠a Energ√©tica Expert BI",
    page_icon="‚ö°",
    layout="wide",
)

# --- ESTILOS DE INGENIER√çA ---
st.markdown("""
    <style>
    .report-container {
        background-color: white; padding: 40px; border-radius: 15px;
        border: 1px solid #e2e8f0; box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        max-width: 1100px; margin: auto; color: #1e293b;
    }
    .metric-card {
        background-color: #f8fafc; padding: 20px; border-radius: 10px;
        border-top: 4px solid #1e40af; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .prompt-box {
        background-color: #0f172a; color: #38bdf8; padding: 25px;
        border-radius: 10px; font-family: 'Consolas', monospace;
        font-size: 0.92em; border: 1px solid #334155; line-height: 1.6;
    }
    .stMetric {
        background: #ffffff; padding: 15px; border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    </style>
""", unsafe_allow_html=True)

# --- MAPEOS Y CONSTANTES ---
DIAS_ORDENADOS = ['Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado', 'Domingo']
DIAS_MAP = {'Monday': 'Lunes', 'Tuesday': 'Martes', 'Wednesday': 'Mi√©rcoles', 'Thursday': 'Jueves', 'Friday': 'Viernes', 'Saturday': 'S√°bado', 'Sunday': 'Domingo'}
MESES_MAP = {'January': 'Enero', 'February': 'Febrero', 'March': 'Marzo', 'April': 'Abril', 'May': 'Mayo', 'June': 'Junio', 'July': 'Julio', 'August': 'Agosto', 'September': 'Septiembre', 'October': 'Octubre', 'November': 'Noviembre', 'December': 'Diciembre'}

# --- PROCESAMIENTO ROBUSTO ---
@st.cache_data
def procesar_archivo_final(uploaded_file):
    try:
        # Lectura con detecci√≥n autom√°tica de delimitador (detecta el ';' del CSV)
        if uploaded_file.name.endswith('.csv'):
            uploaded_file.seek(0)
            df = pd.read_csv(uploaded_file, sep=None, engine='python', encoding='latin-1')
        else:
            try: df = pd.read_excel(uploaded_file, sheet_name="TABLA HORARIA")
            except: df = pd.read_excel(uploaded_file)

        df.columns = df.columns.astype(str).str.strip()

        # Identificaci√≥n de columnas (Normalizaci√≥n de nombres)
        col_fecha = next((c for c in df.columns if c.upper() == 'FECHA'), None)
        col_hora = next((c for c in df.columns if c.upper() == 'HORA'), None)
        col_energia = next((c for c in df.columns if 'ENERGIA' in c.upper()), None)
        col_sede = next((c for c in df.columns if c.upper() == 'NOMBRE'), None)
        col_tarifa = next((c for c in df.columns if c.upper() == 'TARIFA'), None)

        if col_fecha and col_hora:
            # Parseo de Fecha
            df['fecha_dt'] = pd.to_datetime(df[col_fecha], dayfirst=True, errors='coerce', format='mixed')

            # PARSE DE HORA AM/PM (Crucial para corregir Super Valle)
            df['hora_clean'] = df[col_hora].astype(str).str.replace('p. m.', 'PM', case=False).str.replace('a. m.', 'AM', case=False).str.strip()
            temp_time = pd.to_datetime(df['hora_clean'], format='%I:%M:%S %p', errors='coerce')
            df['hora_num'] = temp_time.dt.hour

            # Backup por si el formato es distinto
            if df['hora_num'].isnull().all():
                df['hora_num'] = df[col_hora].astype(str).str.extract('(\d+)').astype(float).fillna(0).astype(int)

            # Limpieza de Energ√≠a (manejo de comas y s√≠mbolos de moneda)
            def clean_val(x):
                if isinstance(x, str):
                    x = x.replace('$', '').replace('.', '').replace(',', '.').strip()
                return pd.to_numeric(x, errors='coerce')

            df['kwh'] = df[col_energia].apply(clean_val).fillna(0)

            # Mantener Tarifa Original
            df['tarifa_original'] = df[col_tarifa].astype(str).str.upper() if col_tarifa else "N/A"

            # Atributos Temporales
            df['dia_nombre'] = df['fecha_dt'].dt.day_name().map(DIAS_MAP)
            df['mes_nombre'] = df['fecha_dt'].dt.month_name().map(MESES_MAP)
            df['sede_label'] = df[col_sede] if col_sede else "Sede General"

            return df.dropna(subset=['fecha_dt'])
        return None
    except Exception as e:
        st.error(f"Error en el procesamiento: {e}")
        return None

# --- UI PRINCIPAL ---
if "auth_state" not in st.session_state: st.session_state.auth_state = False

if not st.session_state.auth_state:
    st.title("üõ°Ô∏è Portal de Consultor√≠a Energ√©tica v6.5")
    u, p = st.text_input("Usuario"), st.text_input("Contrase√±a", type="password")
    if st.button("Ingresar al Sistema"):
        if u == "admin" and p == "admin123":
            st.session_state.auth_state = True
            st.rerun()
else:
    # Sidebar de Configuraci√≥n
    st.sidebar.title("üìä Configuraci√≥n del Informe")
    empresa_consultora = st.sidebar.text_input("Empresa Consultora", "Energy Solutions Global")
    consultor_nombre = st.sidebar.text_input("Consultor Responsable", "Ing. Juan P√©rez")
    fecha_informe = st.sidebar.date_input("Fecha del Informe", datetime.now())
    cliente_nombre = st.sidebar.text_input("Empresa Cliente", "MANUFACTURAS ELIOT")

    st.sidebar.divider()
    logo_file = st.sidebar.file_uploader("Cargar Logo Cliente", type=["png", "jpg", "jpeg"])
    archivo = st.sidebar.file_uploader("Cargar Telemetr√≠a (CSV/Excel)", type=["csv", "xlsx"])

    if archivo:
        data = procesar_archivo_final(archivo)
        if data is not None: st.session_state.df_master = data

    if "df_master" in st.session_state:
        df = st.session_state.df_master

        # Filtro de Sede
        sedes = ["Todas"] + sorted(df['sede_label'].unique().tolist())
        sede_sel = st.sidebar.selectbox("Sede a Analizar", sedes)
        df_view = df if sede_sel == "Todas" else df[df['sede_label'] == sede_sel]

        # --- C√ÅLCULOS GENERALES ---
        perfil_h = df_view.groupby('hora_num')['kwh'].mean().reset_index()
        total_kwh = df_view['kwh'].sum()
        pico_max = df_view['kwh'].max()
        load_factor = (total_kwh / (pico_max * len(df_view))) if pico_max > 0 else 0

        # Estad√≠sticas por Tarifa Original (Sin agrupar)
        resumen_tarifas = df_view.groupby('tarifa_original')['kwh'].agg(['sum', 'mean', 'max']).reset_index()

        tabs = st.tabs(["üìâ Dashboard", "üî• Mapa de Calor", "üîã Baseload & Volatilidad", "üß† Prompt IA Avanzado", "üìÑ Informe"])

        with tabs[0]:
            st.subheader(f"An√°lisis Operativo - {sede_sel}")
            m1, m2, m3, m4 = st.columns(4)
            m1.metric("Energ√≠a Total", f"{total_kwh:,.1f} kWh")
            m2.metric("Pico de Demanda", f"{pico_max:,.1f} kW")
            m3.metric("Factor de Carga", f"{load_factor:.2f}")
            m4.metric("Tarifa Dominante", df_view['tarifa_original'].mode()[0])

            c1, c2 = st.columns(2)
            fig_l_dash = px.line(perfil_h, x='hora_num', y='kwh', title="Curva de Carga Promedio", markers=True)
            c1.plotly_chart(fig_l_dash, use_container_width=True, key="dash_line_main")

            fig_p_dash = px.pie(resumen_tarifas, values='sum', names='tarifa_original', hole=0.4, title="Distribuci√≥n de Energ√≠a por Tarifa Original")
            c2.plotly_chart(fig_p_dash, use_container_width=True, key="dash_pie_main")

        with tabs[1]:
            st.subheader("Mapa de Calor: Intensidad de Consumo")
            heat = df_view.groupby(['dia_nombre', 'hora_num'])['kwh'].mean().reset_index()
            heat_p = heat.pivot(index='hora_num', columns='dia_nombre', values='kwh')
            columnas_ordenadas = [d for d in DIAS_ORDENADOS if d in heat_p.columns]
            fig_h_map = px.imshow(heat_p[columnas_ordenadas], color_continuous_scale='RdYlGn_r', aspect="auto", title="Uso de Energ√≠a por Hora y D√≠a")
            st.plotly_chart(fig_h_map, use_container_width=True, key="heat_map_view")

        with tabs[2]:
            st.subheader("An√°lisis de Carga Base y Estabilidad")
            base_df = df_view.groupby('hora_num')['kwh'].min().reset_index()
            baseload_val = base_df['kwh'].min()

            c1, c2 = st.columns(2)
            with c1:
                st.info(f"Carga Base (Baseload): **{baseload_val:,.2f} kW**")
                fig_base = go.Figure()
                fig_base.add_trace(go.Scatter(x=perfil_h['hora_num'], y=perfil_h['kwh'], name="Promedio", line=dict(color='#1e40af')))
                fig_base.add_trace(go.Scatter(x=base_df['hora_num'], y=base_df['kwh'], name="M√≠nimos", fill='tozeroy', line=dict(color='#10b981')))
                st.plotly_chart(fig_base, use_container_width=True, key="baseload_chart")

            with c2:
                volatilidad = df_view.groupby('hora_num')['kwh'].std().reset_index()
                fig_vol = px.bar(volatilidad, x='hora_num', y='kwh', title="Volatilidad (Desviaci√≥n Est√°ndar)", color_discrete_sequence=['#ef4444'])
                st.plotly_chart(fig_vol, use_container_width=True, key="volatility_chart")

        with tabs[3]:
            st.subheader("Consultor√≠a IA: An√°lisis Profundo de Datos")
            # Preparaci√≥n de datos para el prompt
            top_3_horas = perfil_h.sort_values(by='kwh', ascending=False).head(3)
            tarifas_str = ", ".join([f"{row['tarifa_original']}: {row['sum']:,.0f}kWh" for _, row in resumen_tarifas.iterrows()])

            prompt = f"""
            INFORME T√âCNICO DE AUDITOR√çA ENERG√âTICA
            ---------------------------------------
            CLIENTE: {cliente_nombre} | SEDE: {sede_sel}
            CONSULTOR: {consultor_nombre} | EMPRESA: {empresa_consultora}

            DATOS CR√çTICOS DEL SISTEMA:
            1. ENERG√çA TOTAL: {total_kwh:,.1f} kWh consumidos en el periodo.
            2. PICO M√ÅXIMO (DEMANDA): {pico_max:,.2f} kW.
            3. CARGA BASE (BASELOAD): {baseload_val:,.2f} kW (Consumo constante 24/7).
            4. FACTOR DE CARGA: {load_factor:.2f} (Indicador de eficiencia de uso de potencia).
            5. DESGLOSE POR TARIFAS ORIGINALES: {tarifas_str}.
            6. HORAS DE MAYOR CONSUMO (TOP 3): {top_3_horas['hora_num'].tolist()}.

            SOLICITUD DE AN√ÅLISIS:
            Como experto senior en gesti√≥n energ√©tica:
            - Eval√∫a si el Baseload ({baseload_val:,.2f} kW) es excesivo para una operaci√≥n industrial.
            - Analiza el impacto de los picos de demanda y sugiere si es viable un sistema de Peak Shaving.
            - Basado en el consumo por tarifas (M√≠nima, Media, M√°xima), prop√≥n un plan de desplazamiento de carga (Load Shifting).
            - Identifica anomal√≠as en la volatilidad de carga durante las horas de cambio de turno.
            """
            st.markdown(f'<div class="prompt-box">{prompt}</div>', unsafe_allow_html=True)
            st.caption("Copie este bloque y p√©guelo en su herramienta de IA preferida para generar el an√°lisis detallado.")

        with tabs[4]:
            st.subheader("Informe Profesional Exportable")
            st.markdown('<div class="report-container">', unsafe_allow_html=True)

            # Cabecera Profesional
            col_l, col_r = st.columns([1, 2])
            with col_l:
                if logo_file: st.image(logo_file, width=160)
                else: st.markdown(f"### {empresa_consultora}")
            with col_r:
                st.markdown(f"<h1 style='text-align:right; margin:0;'>INFORME DE AUDITOR√çA</h1>", unsafe_allow_html=True)
                st.markdown(f"<p style='text-align:right; color:#64748b;'><b>Fecha de Emisi√≥n:</b> {fecha_informe.strftime('%d/%m/%Y')}<br><b>Consultor:</b> {consultor_nombre}</p>", unsafe_allow_html=True)

            st.divider()

            # Contenido
            st.markdown(f"### 1. Informaci√≥n General del Cliente")
            st.write(f"**Empresa Cliente:** {cliente_nombre}")
            st.write(f"**Sede / Punto de Medici√≥n:** {sede_sel}")

            st.markdown("### 2. Resumen de Consumo y Demanda")
            st.write(f"Durante el periodo analizado, la sede present√≥ un consumo total de **{total_kwh:,.1f} kWh**. El aprovechamiento de la potencia (Factor de Carga) se sit√∫a en **{load_factor:.2f}**, lo cual indica el perfil de eficiencia operativa.")

            # Gr√°fica para el informe con ID √∫nico
            fig_h_report = px.line(perfil_h, x='hora_num', y='kwh', title="Curva de Carga Promedio del Periodo", markers=True)
            st.plotly_chart(fig_h_report, use_container_width=True, key="report_line_chart")

            st.markdown("### 3. Desglose de Tarifas")
            st.table(resumen_tarifas.rename(columns={'tarifa_original': 'Tarifa', 'sum': 'Total kWh', 'mean': 'Promedio kW', 'max': 'Pico M√°x kW'}))

            st.markdown("### 4. Conclusiones Preliminares")
            st.write(f"- Se detect√≥ un consumo par√°sito (Baseload) de **{baseload_val:,.2f} kW**.")
            st.write(f"- La demanda m√°xima alcanz√≥ los **{pico_max:,.2f} kW**, siendo este el punto cr√≠tico para cargos por potencia.")

            st.markdown(f"<br><br><br><p style='border-top: 1px solid #000; width: 300px; padding-top:10px;'><b>{consultor_nombre}</b><br>{empresa_consultora}</p>", unsafe_allow_html=True)
            st.markdown('</div>', unsafe_allow_html=True)
            st.caption("Sugerencia: Presione Ctrl+P para guardar este informe como PDF.")

    else:
        st.info("üëã Bienvenida, Ingeniero. Por favor, cargue el archivo de telemetr√≠a en el panel izquierdo para iniciar.")