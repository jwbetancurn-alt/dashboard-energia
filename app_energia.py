# -*- coding: utf-8 -*-
"""Aplicaci√≥n de An√°lisis Energ√©tico Pro

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17kvaj4yYD7xDXqBrFDG1flA4xU-9KPE-
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import requests
import json
import base64
from io import BytesIO
from datetime import datetime

# --- CONFIGURACI√ìN DE P√ÅGINA ---
st.set_page_config(
    page_title="IA Energy Consultant Pro",
    page_icon="‚ö°",
    layout="wide",
)

# --- ESTILOS PERSONALIZADOS ---
st.markdown("""
    <style>
    .report-container {
        background-color: white;
        padding: 40px;
        border-radius: 15px;
        border: 1px solid #e2e8f0;
        box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        max-width: 900px;
        margin: auto;
    }
    .stMetric {
        background-color: #ffffff;
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .consultant-info {
        margin-top: 30px;
        border-top: 1px solid #eee;
        padding-top: 20px;
    }
    </style>
""", unsafe_allow_html=True)

# --- MAPEOS DE IDIOMA ---
DIAS_MAP = {
    'Monday': 'Lunes', 'Tuesday': 'Martes', 'Wednesday': 'Mi√©rcoles',
    'Thursday': 'Jueves', 'Friday': 'Viernes', 'Saturday': 'S√°bado', 'Sunday': 'Domingo'
}
MESES_MAP = {
    'January': 'Enero', 'February': 'Febrero', 'March': 'Marzo', 'April': 'Abril',
    'May': 'Mayo', 'June': 'Junio', 'July': 'Julio', 'August': 'Agosto',
    'September': 'Septiembre', 'October': 'Octubre', 'November': 'Noviembre', 'December': 'Diciembre'
}

# --- CONSTANTES Y API ---
API_KEY = ""

def llamar_ia_gemini(prompt):
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key={API_KEY}"
    payload = {"contents": [{"parts": [{"text": prompt}]}]}
    try:
        response = requests.post(url, json=payload, timeout=15)
        response.raise_for_status()
        result = response.json()
        return result['candidates'][0]['content']['parts'][0]['text']
    except Exception:
        return "‚ö†Ô∏è Nota: El an√°lisis de IA no pudo generarse autom√°ticamente."

# --- PROCESAMIENTO DE DATOS ---
@st.cache_data
def procesar_archivo(uploaded_file):
    try:
        if uploaded_file.name.endswith('.csv'):
            for encoding in ['utf-8', 'latin-1', 'iso-8859-1', 'cp1252']:
                try:
                    uploaded_file.seek(0)
                    df = pd.read_csv(uploaded_file, sep=None, engine='python', encoding=encoding)
                    break
                except UnicodeDecodeError:
                    continue
        else:
            try:
                # Intenta primero con la pesta√±a espec√≠fica solicitada
                df = pd.read_excel(uploaded_file, sheet_name="TABLA HORARIA")
            except:
                # Si falla, carga la primera pesta√±a disponible
                df = pd.read_excel(uploaded_file)

        # 1. Limpieza inicial de nombres de columnas
        df.columns = df.columns.astype(str).str.strip()
        df = df.dropna(how='all', axis=0)

        # 2. Identificar columna de FECHA (independiente de may√∫sculas/min√∫sculas)
        cols_originales = list(df.columns)
        col_fecha_orig = next((c for c in cols_originales if c.lower() == 'fecha'), None)

        if col_fecha_orig:
            # Identificar columnas de horas (ej. H1, H2... o h1, h2...)
            value_vars = [c for c in cols_originales if c.upper().startswith('H') and any(char.isdigit() for char in c)]
            id_vars = [c for c in cols_originales if c not in value_vars]

            # Si tiene formato de tabla horaria (H1..H24), hacemos Unpivot
            if value_vars:
                df = df.melt(id_vars=id_vars, value_vars=value_vars, var_name='Hora_Raw', value_name='Energia_Melted')

            # Normalizar nombres de columnas a min√∫sculas para l√≥gica interna
            df.columns = [c.lower() for c in df.columns]

            # 3. B√∫squeda inteligente de la columna de consumo/energ√≠a
            # Buscamos t√©rminos comunes que el usuario podr√≠a tener en su Excel
            terminos_busqueda = ['energia', 'kwh', 'consumo', 'valor', 'active', 'energy', 'total']
            col_kwh = None

            # Prioridad 1: Si acabamos de hacer un melt, la columna se llama 'energia_melted'
            if 'energia_melted' in df.columns:
                col_kwh = 'energia_melted'
            else:
                # Prioridad 2: Buscar coincidencia exacta o parcial con t√©rminos conocidos
                for term in terminos_busqueda:
                    col_found = next((c for c in df.columns if term in c), None)
                    if col_found:
                        col_kwh = col_found
                        break

            if col_kwh:
                # Renombrar para consistencia en el resto del c√≥digo
                df = df.rename(columns={col_kwh: 'kwh', col_fecha_orig.lower(): 'fecha'})

                # Conversi√≥n de tipos de datos
                df['fecha_dt'] = pd.to_datetime(df['fecha'], errors='coerce')
                df['kwh'] = pd.to_numeric(df['kwh'], errors='coerce')

                # Eliminar filas donde la fecha o el consumo sean inv√°lidos
                df = df.dropna(subset=['fecha_dt', 'kwh'])

                # Extraer n√∫mero de hora (si viene de H1..H24) o desde el timestamp
                if 'hora_raw' in df.columns:
                    extracted_hour = df['hora_raw'].astype(str).str.extract('(\d+)')
                    # Ajuste: Si H1 es la 1 AM, etc.
                    df['hora_num'] = pd.to_numeric(extracted_hour[0], errors='coerce').fillna(0).astype(int)
                else:
                    df['hora_num'] = df['fecha_dt'].dt.hour

                # Mapeo de nombres de d√≠as y meses
                df['dia_nombre'] = df['fecha_dt'].dt.day_name().map(DIAS_MAP)
                df['mes_nombre'] = df['fecha_dt'].dt.month_name().map(MESES_MAP)

                # L√≥gica de tarifas horarias
                def categorizar_tarifa(h):
                    if 13 <= h <= 18: return 'Alta (Punta)'
                    elif (7 <= h <= 12) or (19 <= h <= 22): return 'Media (Valle)'
                    return 'Baja (Super Valle)'

                df['tarifa'] = df['hora_num'].apply(categorizar_tarifa)
                df['costo_total'] = df['kwh'] * 0.20 # Factor de costo base

                return df
            else:
                st.error("No se encontr√≥ una columna de consumo. Aseg√∫rese de que su columna se llame 'Energ√≠a', 'kWh' o 'Consumo'.")
        else:
            st.error("No se encontr√≥ la columna 'FECHA'. Por favor, verifique el encabezado de su archivo.")
        return None
    except Exception as e:
        st.error(f"Error t√©cnico durante el procesamiento: {e}")
        return None

# --- M√ìDULO DE AUTENTICACI√ìN ---
def gestionar_login():
    if "auth_state" not in st.session_state:
        st.session_state.auth_state = False
    if not st.session_state.auth_state:
        st.title("üîê Acceso Plataforma Energy BI")
        u = st.text_input("Usuario")
        p = st.text_input("Contrase√±a", type="password")
        if st.button("Ingresar"):
            usuarios = {"admin": "admin123", "cliente": "cliente2025"}
            if u in usuarios and usuarios[u] == p:
                st.session_state.auth_state = True
                st.session_state.user_role = "Administrador" if u == "admin" else "Cliente"
                st.session_state.user_name = u
                st.rerun()
            else:
                st.error("Credenciales incorrectas")
        return False
    return True

# --- INTERFAZ DE USUARIO ---
if gestionar_login():
    st.sidebar.title(f"Sesi√≥n: {st.session_state.user_name}")
    if st.sidebar.button("Cerrar Sesi√≥n"):
        st.session_state.auth_state = False
        st.rerun()

    st.sidebar.divider()

    # Herramientas de Personalizaci√≥n
    st.sidebar.subheader("Personalizaci√≥n")
    logo_file = st.sidebar.file_uploader("Logo Empresa", type=["png", "jpg", "jpeg"])
    nombre_cliente = st.sidebar.text_input("Nombre Cliente", "Empresa ABC")
    nombre_consultor = st.sidebar.text_input("Consultor Responsable", "Juan P√©rez")
    cargo_consultor = st.sidebar.text_input("Cargo", "Analista Energ√©tico")
    mes_informe_sel = st.sidebar.selectbox("Mes Reportado", list(MESES_MAP.values()), index=datetime.now().month - 1)
    fecha_emision = st.sidebar.date_input("Fecha Informe", datetime.now())

    # Carga de archivos exclusiva para Administradores
    if st.session_state.user_role == "Administrador":
        st.sidebar.divider()
        uploaded_file = st.sidebar.file_uploader("Subir Archivo de Datos (CSV/XLSX)", type=["csv", "xlsx"])
        if uploaded_file:
            data = procesar_archivo(uploaded_file)
            if data is not None:
                st.session_state.df_master = data
                st.sidebar.success("‚úÖ Datos procesados con √©xito")

    # Mostrar contenido si hay datos cargados
    if "df_master" in st.session_state:
        df = st.session_state.df_master

        # Filtro opcional por columna 'nombre' si existe en el archivo
        col_filtro = 'nombre' if 'nombre' in df.columns else None
        nombres = ["Todos"] + sorted(list(df[col_filtro].unique())) if col_filtro else ["Todos"]
        sede_seleccionada = st.sidebar.selectbox("Filtrar por Sede/Nombre", nombres)

        df_view = df if sede_seleccionada == "Todos" else df[df[col_filtro] == sede_seleccionada]

        t1, t2, t3, t4 = st.tabs(["üìä Gr√°ficos", "üî¨ Explorador", "ü§ñ Consultor√≠a IA", "üìú Informe"])

        with t1:
            st.subheader(f"Perfil de Consumo: {nombre_cliente}")
            if 'hora_num' in df_view.columns:
                c1, c2 = st.columns(2)
                # Gr√°fico de curva horaria promedio
                df_h = df_view.groupby('hora_num')['kwh'].mean().reset_index()
                c1.plotly_chart(px.line(df_h, x='hora_num', y='kwh',
                                       title="Demanda Promedio por Hora",
                                       labels={'hora_num': 'Hora del D√≠a', 'kwh': 'Consumo (kWh)'}),
                               use_container_width=True)

                # Gr√°fico de consumo por d√≠a de la semana
                df_d = df_view.groupby('dia_nombre')['kwh'].sum().reset_index()
                c2.plotly_chart(px.bar(df_d, x='dia_nombre', y='kwh',
                                       category_orders={"dia_nombre": list(DIAS_MAP.values())},
                                       title="Consumo Total por D√≠a de la Semana",
                                       color_discrete_sequence=['#1e40af']),
                               use_container_width=True)
            else:
                st.warning("Formato de datos insuficiente para generar gr√°ficas.")

        with t2:
            st.subheader("Laboratorio de Datos")
            # Selecci√≥n din√°mica de ejes para flexibilidad
            columnas_disp = [c for c in df_view.columns if c in ["hora_num", "dia_nombre", "tarifa", "mes_nombre"]]
            cx, cy = st.columns(2)
            sel_x = cx.selectbox("Agrupar por:", columnas_disp)
            sel_y = cy.selectbox("M√©trica:", ["kwh", "costo_total"])

            df_custom = df_view.groupby(sel_x)[sel_y].sum().reset_index()
            st.plotly_chart(px.bar(df_custom, x=sel_x, y=sel_y, title=f"{sel_y.upper()} acumulado por {sel_x}"), use_container_width=True)

        with t3:
            st.subheader("An√°lisis Estrat√©gico con Inteligencia Artificial")
            # Simulaci√≥n de desplazamiento de carga
            p_desplazar = st.slider("% de carga a desplazar de Horario Punta", 0, 100, 20)
            e_punta = df_view[df_view['tarifa'] == 'Alta (Punta)']['kwh'].sum() if 'tarifa' in df_view.columns else 0
            ahorro_calc = e_punta * (p_desplazar/100) * 0.12 # Estimaci√≥n de ahorro por diferencial tarifario

            st.metric("Potencial de Ahorro Econ√≥mico", f"${ahorro_calc:,.2f}")

            if st.button("ü™Ñ Ejecutar Auditor√≠a IA"):
                with st.spinner("La IA est√° analizando los patrones..."):
                    contexto = f"Empresa: {nombre_cliente}. Consumo total: {df_view['kwh'].sum():,.2f} kWh. Potencial ahorro: ${ahorro_calc:,.2f}."
                    st.session_state.ia_result = llamar_ia_gemini(f"Act√∫a como consultor energ√©tico experto. Analiza estos datos y da 3 recomendaciones clave: {contexto}")
                    st.success("An√°lisis completado")
                    st.markdown(st.session_state.ia_result)

        with t4:
            st.subheader("Generaci√≥n de Informe Ejecutivo")
            # Renderizado del reporte con CSS embebido
            with st.container():
                st.markdown('<div class="report-container">', unsafe_allow_html=True)

                h_col1, h_col2 = st.columns([1, 2])
                with h_col1:
                    if logo_file: st.image(logo_file, width=150)
                    else: st.markdown("### [Logo]")
                with h_col2:
                    st.markdown(f"<h1 style='text-align:right; color:#1e40af; margin-top:0;'>REPORTE DE AUDITOR√çA</h1>", unsafe_allow_html=True)
                    st.markdown(f"<p style='text-align:right;'>Periodo: {mes_informe_sel} {fecha_emision.year}</p>", unsafe_allow_html=True)

                st.divider()
                st.markdown(f"**Cliente:** {nombre_cliente}")
                st.markdown(f"**Fecha de Emisi√≥n:** {fecha_emision.strftime('%d/%m/%Y')}")

                # Resumen de m√©tricas en el informe
                res1, res2, res3 = st.columns(3)
                res1.metric("Consumo Total", f"{df_view['kwh'].sum():,.2f} kWh")
                res2.metric("Promedio Horario", f"{df_view['kwh'].mean():,.2f} kWh")
                res3.metric("Ahorro Identificado", f"${ahorro_calc:,.2f}")

                st.markdown("---")
                st.markdown("#### Conclusiones de la IA")
                st.info(st.session_state.get("ia_result", "Por favor, ejecute el an√°lisis en la pesta√±a anterior para incluir conclusiones en este informe."))

                # Espacio para firma
                st.markdown(f"<br><br><br><p style='border-top: 1px solid #333; display:inline-block; padding-top:5px; min-width:250px;'><b>{nombre_consultor}</b><br>{cargo_consultor}</p>", unsafe_allow_html=True)

                st.markdown('</div>', unsafe_allow_html=True)

            st.caption("Para exportar: Use la funci√≥n de imprimir del navegador (Ctrl+P) y guarde como PDF.")
    else:
        st.info("üëã Bienvenido. Cargue un archivo CSV o Excel en el men√∫ lateral para iniciar el an√°lisis.")