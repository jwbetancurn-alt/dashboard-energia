# -*- coding: utf-8 -*-
"""Aplicaci√≥n de Consultor√≠a Energ√©tica Avanzada

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JcI908HEx7KYgZqIkewPCxZ-3-dUZWLT
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np
from datetime import datetime

# --- CONFIGURACI√ìN DE P√ÅGINA ---
st.set_page_config(
    page_title="Consultor√≠a Energ√©tica Expert BI v9.5",
    page_icon="‚ö°",
    layout="wide",
)

# --- ESTILOS DE INGENIER√çA Y PRINT CSS ---
st.markdown("""
    <style>
    @media print {
        .no-print, [data-testid="stSidebar"], .stTabs [role="tablist"], .stButton, button {
            display: none !important;
        }
        .report-container {
            border: none !important; box-shadow: none !important;
            padding: 0 !important; width: 100% !important; margin: 0 !important;
        }
        .stPlotlyChart { page-break-inside: avoid !important; margin-bottom: 20px; }
        .page-break { page-break-before: always; }
    }
    .report-container {
        background-color: white; padding: 40px; border-radius: 10px;
        border: 1px solid #e2e8f0; box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        max-width: 1200px; margin: auto; color: #1e293b;
    }
    .prompt-box {
        background-color: #0f172a; color: #38bdf8; padding: 25px;
        border-radius: 10px; font-family: 'Consolas', monospace;
        font-size: 0.85em; border: 1px solid #334155; line-height: 1.6;
    }
    .metric-card {
        background: #f8fafc; border: 1px solid #cbd5e1;
        padding: 15px; border-radius: 8px; text-align: center;
    }
    .saving-card {
        background: #f0fdf4; border: 2px solid #22c55e;
        padding: 20px; border-radius: 12px; color: #166534;
    }
    </style>
""", unsafe_allow_html=True)

# --- CONSTANTES ---
DIAS_ORDENADOS = ['Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado', 'Domingo']
MESES_ORDENADOS = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre']

@st.cache_data
def procesar_datos_v9(uploaded_file):
    try:
        if uploaded_file.name.endswith('.csv'):
            uploaded_file.seek(0)
            df = pd.read_csv(uploaded_file, sep=None, engine='python', encoding='latin-1')
        else:
            try: df = pd.read_excel(uploaded_file, sheet_name="TABLA HORARIA")
            except: df = pd.read_excel(uploaded_file)

        df.columns = df.columns.astype(str).str.strip()

        c_fecha = next((c for c in df.columns if c.upper() == 'FECHA'), None)
        c_hora = next((c for c in df.columns if c.upper() == 'HORA'), None)
        c_energia = next((c for c in df.columns if 'ENERGIA' in c.upper()), None)
        c_val_unit = next((c for c in df.columns if 'VALOR KWH' in c.upper()), None)
        c_val_total = next((c for c in df.columns if 'VALOR CONSUMO' in c.upper()), None)
        c_sede = next((c for c in df.columns if c.upper() == 'NOMBRE'), None)
        c_tarifa = next((c for c in df.columns if c.upper() == 'TARIFA'), None)

        if c_fecha and c_hora:
            df['fecha_dt'] = pd.to_datetime(df[c_fecha], dayfirst=True, errors='coerce', format='mixed')
            df['hora_clean'] = df[c_hora].astype(str).str.replace('p. m.', 'PM', case=False).str.replace('a. m.', 'AM', case=False).str.strip()
            temp_time = pd.to_datetime(df['hora_clean'], format='%I:%M:%S %p', errors='coerce')
            df['hora_num'] = temp_time.dt.hour
            if df['hora_num'].isnull().all():
                df['hora_num'] = df[c_hora].astype(str).str.extract('(\d+)').astype(float).fillna(0).astype(int)

            def clean_num(x):
                if isinstance(x, str): x = x.replace('$', '').replace('.', '').replace(',', '.').strip()
                return pd.to_numeric(x, errors='coerce')

            df['kwh'] = df[c_energia].apply(clean_num).fillna(0)
            df['precio_kwh'] = df[c_val_unit].apply(clean_num).fillna(0) if c_val_unit else 0
            df['costo_total'] = df[c_val_total].apply(clean_num).fillna(0) if c_val_total else 0
            df['tarifa_label'] = df[c_tarifa].astype(str).str.upper() if c_tarifa else "UNICA"
            df['dia_nombre'] = df['fecha_dt'].dt.day_name().map({'Monday':'Lunes','Tuesday':'Martes','Wednesday':'Mi√©rcoles','Thursday':'Jueves','Friday':'Viernes','Saturday':'S√°bado','Sunday':'Domingo'})
            df['mes_nombre'] = df['fecha_dt'].dt.month_name().map({'January':'Enero','February':'Febrero','March':'Marzo','April':'Abril','May':'Mayo','June':'Junio','July':'Julio','August':'Agosto','September':'Septiembre','October':'Octubre','November':'Noviembre','December':'Diciembre'})
            df['sede_label'] = df[c_sede] if c_sede else "Sede General"

            return df.dropna(subset=['fecha_dt'])
        return None
    except Exception as e:
        st.error(f"Error: {e}")
        return None

if "auth" not in st.session_state: st.session_state.auth = False

if not st.session_state.auth:
    st.title("üõ°Ô∏è Portal de Auditor√≠a Energ√©tica v9.5")
    u, p = st.text_input("Ingeniero"), st.text_input("Clave", type="password")
    if st.button("Ingresar"):
        if u == "admin" and p == "admin123": st.session_state.auth = True; st.rerun()
else:
    st.sidebar.title("üè¢ Auditor√≠a")
    cons_empresa = st.sidebar.text_input("Consultora", "Expert BI Solutions")
    cons_nombre = st.sidebar.text_input("Auditor", "Ing. Senior")
    cliente = st.sidebar.text_input("Cliente", "MANUFACTURAS ELIOT")
    fecha_inf = st.sidebar.date_input("Fecha Reporte", datetime.now())
    logo = st.sidebar.file_uploader("Logo Corporativo", type=["png", "jpg"])

    file = st.sidebar.file_uploader("Telemetr√≠a", type=["csv", "xlsx"])
    if file:
        d = procesar_datos_v9(file)
        if d is not None: st.session_state.master = d

    if "master" in st.session_state:
        df = st.session_state.master
        puntos = ["Todos"] + sorted(df['sede_label'].unique().tolist())
        punto_sel = st.sidebar.selectbox("Punto de Medici√≥n", puntos)
        dfv = df if punto_sel == "Todos" else df[df['sede_label'] == punto_sel]

        # --- CALCULOS DE INGENIER√çA ---
        total_kwh = dfv['kwh'].sum()
        pico_max = dfv['kwh'].max()
        val_kwh_avg = dfv[dfv['precio_kwh'] > 0]['precio_kwh'].mean()

        reales = dfv[dfv['kwh'] > 0]
        if not reales.empty:
            min_diarios = reales.groupby('fecha_dt')['kwh'].min()
            baseload_avg = min_diarios.mean()
        else: baseload_avg = 0

        load_factor = (total_kwh / (pico_max * len(dfv))) if pico_max > 0 else 0

        # Agregaciones para gr√°ficas
        perfil_h = dfv.groupby('hora_num')['kwh'].mean().reset_index()
        consumo_mes = dfv.groupby('mes_nombre')['kwh'].sum().reset_index()
        consumo_dia = dfv.groupby('dia_nombre')['kwh'].sum().reset_index()
        dist_tarifa = dfv.groupby('tarifa_label')['kwh'].sum().reset_index()
        costo_h = dfv.groupby('hora_num')['costo_total'].sum().reset_index()

        tabs = st.tabs(["üìâ Dashboard Pro", "üî• Mapas T√©rmicos", "üí∞ Proyecci√≥n Ahorros", "üé® Graficador", "üß† IA Auditor", "üìÑ Informe Final"])

        with tabs[0]:
            st.subheader(f"Dashboard de Telemetr√≠a: {punto_sel}")
            k1, k2, k3, k4 = st.columns(4)
            k1.metric("Consumo Total", f"{total_kwh:,.0f} kWh")
            k2.metric("Pico de Potencia", f"{pico_max:,.2f} kW")
            k3.metric("Factor de Carga", f"{load_factor:.2f}")
            k4.metric("Precio Medio", f"${val_kwh_avg:,.2f}/kWh")

            c1, c2 = st.columns(2)
            fig_l1 = px.area(consumo_mes, x='mes_nombre', y='kwh', title="Evoluci√≥n Mensual Acumulada", category_orders={'mes_nombre': MESES_ORDENADOS}, labels={'kwh':'Energ√≠a (kWh)'})
            c1.plotly_chart(fig_l1, use_container_width=True, key="dash_l1")

            fig_b1 = px.bar(consumo_dia, x='dia_nombre', y='kwh', color='kwh', title="Pareto de Consumo por D√≠a", category_orders={'dia_nombre': DIAS_ORDENADOS})
            c2.plotly_chart(fig_b1, use_container_width=True, key="dash_b1")

            c3, c4 = st.columns(2)
            fig_p1 = px.line(perfil_h, x='hora_num', y='kwh', title="Curva de Carga Promedio (kW)", markers=True)
            c3.plotly_chart(fig_p1, use_container_width=True, key="dash_p1")

            fig_pie1 = px.pie(dist_tarifa, values='kwh', names='tarifa_label', hole=0.4, title="Distribuci√≥n por Franja Tarifaria")
            c4.plotly_chart(fig_pie1, use_container_width=True, key="dash_pie1")

            c5, c6 = st.columns(2)
            fig_cost1 = px.bar(costo_h, x='hora_num', y='costo_total', title="Impacto Econ√≥mico por Hora del D√≠a", labels={'costo_total':'Costo Total ($)'})
            c5.plotly_chart(fig_cost1, use_container_width=True, key="dash_cost1")

            fig_scat1 = px.scatter(dfv, x='kwh', y='precio_kwh', color='tarifa_label', title="Dispersi√≥n: Consumo vs Precio Unitario", opacity=0.5)
            c6.plotly_chart(fig_scat1, use_container_width=True, key="dash_scat1")

        with tabs[1]:
            st.subheader("An√°lisis de Intensidad")
            ch1, ch2 = st.columns(2)
            h1 = dfv.groupby(['dia_nombre', 'hora_num'])['kwh'].mean().reset_index().pivot(index='hora_num', columns='dia_nombre', values='kwh')
            fig_h1 = px.imshow(h1[[d for d in DIAS_ORDENADOS if d in h1.columns]], color_continuous_scale='Viridis', title="Densidad Horaria vs D√≠a")
            ch1.plotly_chart(fig_h1, use_container_width=True, key="dash_h1")

            fig_box = px.box(dfv, x='hora_num', y='kwh', title="Dispersi√≥n de Carga por Hora (Estabilidad)", labels={'kwh':'Demanda (kW)'})
            ch2.plotly_chart(fig_box, use_container_width=True, key="dash_box1")

        with tabs[2]:
            st.subheader("Simulador Avanzado de Load Shifting & Eficiencia")
            st.write("Mueva el consumo entre franjas para calcular el ahorro proyectado basado en precios reales.")

            precios_map = dfv[dfv['precio_kwh'] > 0].groupby('tarifa_label')['precio_kwh'].mean().to_dict()
            p_max = precios_map.get('MAXIMA', val_kwh_avg * 1.2)
            p_med = precios_map.get('MEDIA', val_kwh_avg)
            p_min = precios_map.get('MINIMA', val_kwh_avg * 0.8)

            sl1, sl2, sl3 = st.columns(3)
            red_pico = sl1.slider("% Reducci√≥n de Picos (Peak Shaving)", 0, 40, 10)
            shift_max_med = sl2.slider("% Mover de M√ÅXIMA a MEDIA", 0, 50, 15)
            shift_med_min = sl3.slider("% Mover de MEDIA a M√çNIMA", 0, 50, 20)

            kwh_max = dfv[dfv['tarifa_label'] == 'MAXIMA']['kwh'].sum()
            kwh_med = dfv[dfv['tarifa_label'] == 'MEDIA']['kwh'].sum()

            ahorro_sh_1 = (kwh_max * (shift_max_med/100)) * (p_max - p_med)
            ahorro_sh_2 = (kwh_med * (shift_med_min/100)) * (p_med - p_min)
            ahorro_pico = (pico_max * (red_pico/100)) * 22 * 4 * val_kwh_avg

            total_ahorro = ahorro_sh_1 + ahorro_sh_2 + ahorro_pico

            st.markdown(f"""
            <div class='saving-card'>
                <h3 style='margin:0'>üí∞ Ahorro Mensual Proyectado: ${total_ahorro:,.2f}</h3>
                <p>Desglose: Shift Max-Med (${ahorro_sh_1:,.0f}) + Shift Med-Min (${ahorro_sh_2:,.0f}) + Peak Shaving (${ahorro_pico:,.0f})</p>
            </div>
            """, unsafe_allow_html=True)

        with tabs[3]:
            st.subheader("üé® Custom Analytics Sandbox")
            c_x = st.selectbox("Dimensi√≥n (X)", ['hora_num', 'dia_nombre', 'mes_nombre', 'tarifa_label'])
            c_y = st.selectbox("M√©trica (Y)", ['kwh', 'precio_kwh', 'costo_total'])
            tipo = st.radio("Tipo de Gr√°fica", ['Barras', 'L√≠neas', 'Dispersi√≥n'], horizontal=True)
            if tipo == 'Barras': fig_c = px.bar(dfv, x=c_x, y=c_y, color='tarifa_label')
            elif tipo == 'L√≠neas': fig_c = px.line(dfv, x=c_x, y=c_y, color='tarifa_label')
            else: fig_c = px.scatter(dfv, x=c_x, y=c_y, color='tarifa_label', opacity=0.4)
            st.plotly_chart(fig_c, use_container_width=True, key="custom_chart")

        with tabs[4]:
            st.subheader("üß† Prompt para Consultor√≠a IA Avanzada")
            t_data = dfv.groupby('tarifa_label')['kwh'].agg(['sum', 'mean']).reset_index()
            tarifas_inf = "; ".join([f"{r['tarifa_label']} (Precio Ref: ${precios_map.get(r['tarifa_label'], val_kwh_avg):,.1f})" for _, r in t_data.iterrows()])

            prompt = f"""
            Act√∫a como un Auditor de Energ√≠a Industrial Senior y Experto en Mercados El√©ctricos.
            Cliente: {cliente} | Sede: {punto_sel}.

            AN√ÅLISIS DE TELEMETR√çA:
            - Energ√≠a Totalizada: {total_kwh:,.0f} kWh.
            - Demanda M√°xima Registrada: {pico_max:,.2f} kW.
            - Carga Base (Uso 24/7): {baseload_avg:,.2f} kW.
            - Factor de Carga Operativo: {load_factor:.2f}.
            - Precio Medio Ponderado: ${val_kwh_avg:,.2f}/kWh.
            - Estructura Tarifaria Detectada: {tarifas_inf}.

            REQUERIMIENTOS T√âCNICOS ADICIONALES:
            1. EVALUACI√ìN DE EFICIENCIA: Analiza si el factor de carga {load_factor:.2f} es √≥ptimo para este tipo de industria o si indica subutilizaci√≥n de la infraestructura.
            2. CALIDAD DE ENERG√çA Y ARM√ìNICOS: Deduce riesgos te√≥ricos de distorsi√≥n arm√≥nica total (THD) basados en el perfil de carga y sugiere puntos de medici√≥n para filtros activos.
            3. ESTRATEGIA DE CARGOS POR CAPACIDAD: Calcula el impacto econ√≥mico de los picos de {pico_max:,.2f} kW en la factura de transporte y distribuci√≥n.
            4. PROYECCI√ìN SOLAR + BESS: Dise√±a una soluci√≥n h√≠brida para desplazar el consumo de la franja M√ÅXIMA a M√çNIMA usando bater√≠as, calculando un ROI estimado.
            5. MERCADO NO REGULADO: ¬øEs viable para este cliente migrar al mercado no regulado dado su volumen de {total_kwh:,.0f} kWh? Justifica t√©cnicamente.
            6. TRANSFORMADORES: Eval√∫a p√©rdidas te√≥ricas por efecto Joule bas√°ndose en el perfil de demanda horaria.
            """
            st.markdown(f'<div class="prompt-box">{prompt}</div>', unsafe_allow_html=True)
            st.caption("Copia este prompt y √∫salo en Gemini/ChatGPT para generar la narrativa del informe.")

        with tabs[5]:
            st.subheader("Informe T√©cnico de Auditor√≠a")
            st.markdown('<button onclick="window.print()" style="padding:10px 20px; background:#1e3a8a; color:white; border:none; border-radius:5px; cursor:pointer;">üì• Exportar a PDF (Imprimir)</button>', unsafe_allow_html=True)

            st.markdown('<div class="report-container">', unsafe_allow_html=True)
            col_l, col_r = st.columns([1, 2])
            with col_l:
                if logo: st.image(logo, width=150)
                else: st.markdown(f"### {cons_empresa}")
            with col_r:
                st.markdown(f"<h1 style='text-align:right; margin:0;'>REPORTE T√âCNICO ENERG√âTICO</h1>", unsafe_allow_html=True)
                st.markdown(f"<p style='text-align:right; color:#64748b;'><b>Cliente:</b> {cliente}<br><b>Auditor:</b> {cons_nombre}<br><b>Fecha:</b> {fecha_inf}</p>", unsafe_allow_html=True)

            st.divider()

            st.markdown("### 1. Indicadores de Gesti√≥n Energ√©tica (KPIs)")
            rk1, rk2, rk3, rk4 = st.columns(4)
            rk1.metric("Energ√≠a Total (kWh)", f"{total_kwh:,.0f}")
            rk2.metric("Demanda M√°x (kW)", f"{pico_max:,.2f}")
            rk3.metric("Carga Base (kW)", f"{baseload_avg:,.2f}")
            rk4.metric("Factor Carga", f"{load_factor:.2f}")

            st.markdown("### 2. An√°lisis de Comportamiento Temporal")
            st.plotly_chart(fig_l1, use_container_width=True, key="rep_l1")
            st.plotly_chart(fig_p1, use_container_width=True, key="rep_p1")
            st.plotly_chart(fig_b1, use_container_width=True, key="rep_b1")

            st.markdown("<div class='page-break'></div>", unsafe_allow_html=True)

            st.markdown("### 3. Diagn√≥stico de Franjas y Costos")
            col_rep_a, col_rep_b = st.columns(2)
            col_rep_a.plotly_chart(fig_pie1, use_container_width=True, key="rep_pie1")
            col_rep_b.plotly_chart(fig_cost1, use_container_width=True, key="rep_cost1")

            st.markdown("### 4. Estabilidad y Densidad de Carga")
            st.plotly_chart(fig_h1, use_container_width=True, key="rep_h1")
            st.plotly_chart(fig_box, use_container_width=True, key="rep_box1")

            st.markdown("### 5. Oportunidades de Optimizaci√≥n Econ√≥mica")
            st.write(f"Mediante la implementaci√≥n de **Load Shifting** y **Peak Shaving**, se proyecta un ahorro mensual de:")
            st.markdown(f"<h2 style='color:#16a34a'>${total_ahorro:,.2f} / Mes</h2>", unsafe_allow_html=True)

            st.table(t_data.rename(columns={'tarifa_label':'Franja','sum':'kWh Acumulados','mean':'Promedio kW'}))

            st.markdown("### 6. Conclusiones T√©cnicas")
            st.write(f"- El punto de medici√≥n **{punto_sel}** presenta un perfil de carga {'estable' if load_factor > 0.7 else 'vol√°til'}.")
            st.write(f"- Se recomienda desplazar al menos un {shift_max_med}% de la carga de franja M√ÅXIMA para optimizar el OPEX.")
            st.write(f"- La carga base de {baseload_avg:,.2f} kW sugiere potencial de mejora en sistemas de iluminaci√≥n o climatizaci√≥n.")

            st.markdown(f"<br><br><p style='border-top:1px solid #000; width:300px'><b>Firma Autorizada</b><br>{cons_nombre}<br>{cons_empresa}</p>", unsafe_allow_html=True)
            st.markdown('</div>', unsafe_allow_html=True)

    else:
        st.info("üëã Por favor, cargue la telemetr√≠a en el panel lateral.")